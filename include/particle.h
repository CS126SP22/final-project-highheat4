#pragma once

#include "cinder/gl/gl.h"

using glm::vec2;

namespace idealgas {

/**
 * The particle object storing position and velocity.
 */
  class Particle {
  public:

    /**
     * Initializes a particle
     * @param position is the initial position of the particle
     * @param velocity is the initial velocity of the particle
     * @param radius is the permanent radius of the particle
     * @param mass is the permanent mass of the particle
     * @param color is the permanent color of the particle
     */
    Particle(vec2 position, vec2 velocity, float radius,
          float mass, ci::Color color);

    /**
     * Spawns multiple particles into a vector; controls what types of particles get made
     * @param count the number of particles we want to make.
     * @return The vector storing all of the generated particles.
     */
    static std::vector<Particle> SpawnParticles(size_t count);

    /**
     * Updates the particle position based on its velocity.
     */
    void Move();

    // Getters
    glm::vec2 GetPosition() const;
    glm::vec2 GetVelocity();
    float GetMass();
    float GetRadius() const;
    ci::Color GetColor() const;

    // Setter
    void SetVelocity(glm::vec2);

    /**
     * Calculates velocity changes given that "this" particle and particle_2 collide.
     * @param particle_2 the second particle to check a collision against.
     * @return the velocity vectors of the two particles.
     */
    std::vector<vec2> CalculateCollisionResults(Particle particle_2);

    /**
     * Calculates the distance between "this" particle and particle_2
     * @param particle_2 the particle to check distance against.
     * @return the distance between the two particles.
     */
    float CalculateDistance(Particle particle_2) const;

    /**
     * Calculates a random double between fMin and fMax.
     * @param fMin the minimum randomized double that can be returned.
     * @param fMax the maximum randomized double that can be returned.
     * @return A random double between fMin and fMax.
     */
    static double fRand(double fMin, double fMax);

    /**
     * Checks whether a collision occurs against a rectangular container.
     * @param left_wall the left wall.
     * @param right_wall the right wall.
     * @param top_wall the top wall.
     * @param bottom_wall the bottom wall.
     */
    void CheckContainerCollision(float left_wall, float right_wall, float top_wall, float bottom_wall);

    /**
     * Calculates whether "this" particle is contacting particle_2.
     * @param particle_2 The second particle.
     * @return Whether "this" particle and particle_2 are in contact.
     */
    bool IsTouchingParticles(Particle particle_2) const;

    /**
     * Calculates whether "this" particle is approaching particle_2.
     * @param particle_2 The second particle.
     * @return whether "this" particle is approaching particle_2.
     */
    bool ApproachesOtherParticle(Particle particle_2);

  private:
    /**
     * Default spawn width.
     */
    static const size_t kDefaultWidth = 700;

    /**
     * Default spawn height.
     */
    static const size_t kDefaultHeight = 500;

    /**
     * Default spawn x coordinate.
     */
    static const int kDefaultXCoord = 100;

    /**
     * Default spawn y coordinate.
     */
    static const int kDefaultYCoord = 100;

    /**
     * Individual particle position, velocity, mass, radius, and color.
     */
    glm::vec2 position_;
    glm::vec2 velocity_;
    float mass_;
    float radius_;
    ci::Color color_;

    /**
     * Calculates the new negated velocity given a wall collision.
     * @param x_or_y Whether we are negating the x value or the y value of the velocity.
     * @return The new velocity of a particle that has contacted a wall.
     */
    vec2 GetNegatedVelocity(bool x_or_y);

    /**
     * Creates particles one at a time.
     * @param new_radius the radius of the particle to be generated.
     * @param new_mass the mass of the particle to be generated.
     * @param new_color the color of the particle to be generated.
     * @return the Particle generated by the function.
     */
    static Particle GenerateRandomParticle(float new_radius, float new_mass, cinder::Color new_color);

    /**
     * Helper function to apply collision formula.
     * @param particle_2 the particle that "this" is colliding against.
     * @return "this" particle's updated velocity given that it has collided with particle_2.
     */
    vec2 ApplyCollisionFormula(Particle particle_2);
  };

}